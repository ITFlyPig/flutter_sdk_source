///
/// 控制一个可滚动的小部件
///
/// 滚动控制器（Scroll controllers）通常作为成员变量存储在 [State] 对象中，并在每次
/// [State.build] 中重复使用。单个滚动控制器（scroll controller）可用于控制多个可滚动小
/// 组件，但有些操作，如读取滚动 [offset]，需要控制器与单个可滚动小组件一起使用。
///
/// 滚动控制器（scroll controller）创建一个[ScrollPosition]来管理特定于单个[Scrollable]
/// widget的状态。要使用自定义的[ScrollPosition]，请继承[ScrollController并重写[createScrollPosition]。
///
/// [ScrollController]是一个[Listenable]，每当任何一个附加的[ScrollPosition]通知它们的
/// listeners时，[ScrollController]就会通知listeners（即每当它们中的任何一个滚动时）。
/// 当附加的[ScrollPosition]列表发生变化时，它不会通知它的listeners。
///
/// 通常与[ListView]、[GridView]、[CustomScrollView]一起使用。
///
/// See also:
/// * [ListView]、[GridView]、[CustomScrollView]，可以通过[ScrollController]来控制。
/// * [Scrollable]，它是创建和关联[ScrollPosition]和[ScrollController]的比较底层的widget。
/// * [PageController]，它可以控制类似[PageView]的对象。
/// * [ScrollPosition]，管理单个滚动部件的滚动偏移（offset）。
/// * [ScrollNotification]和[NotificationListener]，可用于观察滚动位置，而无需使用[ScrollController]。
///
///
class ScrollController extends ChangeNotifier {
  /// 为了滚动小部件创建一个控制器
  ///
  /// T`initialScrollOffset` and `keepScrollOffset` 的值必须不为null.
  ScrollController({
    double initialScrollOffset = 0.0,
    this.keepScrollOffset = true,
    this.debugLabel,
  }) :
        _initialScrollOffset = initialScrollOffset;

  /// [offset]的初始值
  ///
  /// 如果[keepScrollOffset]为false或滚动偏移量尚未保存，则创建并附着到该控制器的新
  /// [ScrollPosition]对象将被初始化为该值。
  ///
  /// 默认是0.0
  ///
  double get initialScrollOffset => _initialScrollOffset;
  final double _initialScrollOffset;

  /// 每次滚动完成后，用[PageStorage]保存当前滚动[[offset] ，如果重新创建了这个控制器的
  /// scrollable，则恢复它。
  ///
  /// Each time a scroll completes, save the current scroll [offset] with
  /// [PageStorage] and restore it if this controller's scrollable is recreated.
  ///
  /// 如果此属性设置为false，则永远不会保存滚动偏移，而[initialScrollOffset]总是用于初始
  /// 化滚动偏移。如果为true（默认值），则在第一次创建控制器的可滚动对象时使用初始滚动偏移，
  /// 因为还没有滚动偏移需要恢复。随后将恢复保存的偏移量，并忽略[initialScrollOffset]。
  ///
  /// See also:
  ///
  ///  * [PageStorageKey]，当同一路由中出现多个scrollable时，应该使用它来区分用于保存滚
  ///     动偏移量的[PageStorage]位置。
  final bool keepScrollOffset;

  /// A label that is used in the [toString] output. Intended to aid with
  /// identifying scroll controller instances in debug output.
  final String? debugLabel;

  /// 当前附着的positions集合
  ///
  /// 这个不应该直接修改。[ScrollPosition]对象可以使用[attach]和[detach]来添加和删除。
  @protected
  Iterable<ScrollPosition> get positions => _positions;
  final List<ScrollPosition> _positions = <ScrollPosition>[];

  /// 是否有任何[ScrollPosition]对象使用[attach]方法f附着到[ScrollController]上。
  ///
  /// Whether any [ScrollPosition] objects have attached themselves to the
  /// [ScrollController] using the [attach] method.
  ///
  /// 如果为false，那么与[ScrollPosition]交互的成员，如[position]、[offset]、[animateTo]和[jumpTo]，就不能被调用。
  bool get hasClients => _positions.isNotEmpty;

  /// 返回附着的[ScrollPosition]，从中可以得到[ScrollView]的实际滚动偏移量。
  ///
  /// 只有当只当position附着时，这个调用才有效。
  ScrollPosition get position {
    return _positions.single;
  }

  /// 当前scrollable widget的滚动偏移量
  ///
  /// 要求控制器正好控制一个可滚动的小部件（scrollable widget）。
  double get offset => position.pixels;

  /// 动画的方式从当前位置移动到指定位置
  ///
  /// 任何活动的动画都会被取消。如果用户当前正在滚动，则该动作被取消。
  ///
  /// 返回的[Future]将在动画结束时完成，不管是成功完成还是提前中断。
  ///
  /// 每当用户试图手动滚动，或者每当另一个活动（activity）开始，或者每当动画到达视窗边缘并
  /// 试图过度滚动时，动画就会被中断。如果[ScrollPosition]不overscroll，而是允许滚动到外
  /// 延之外，那么超出外延就不会中断动画。
  ///
  /// 动画不关心视窗或内容尺寸的变化
  ///
  /// 一旦动画完成，在其数值不稳定的情况下，滚动位置将尝试开始弹道活动[ ballistic activity]
  /// （例如，如果它的滚动超过了外延，在这种情况下，滚动位置通常会反弹）。
  ///
  /// 持续时间不能为零。要在没有动画的情况下跳转到一个特定的值，使用[jumpTo]。
  ///
  /// 在widget测试中调用[animateTo]时，"await "返回的[Future]可能会导致测试挂起并超时。
  /// 相反，使用[WidgetTester.pumpAndSettle]。
  ///
  Future<void> animateTo(
      double offset, {
        required Duration duration,
        required Curve curve,
      }) async {
    await Future.wait<void>(<Future<void>>[
      for (int i = 0; i < _positions.length; i += 1) _positions[i].animateTo(offset, duration: duration, curve: curve),
    ]);
  }

  /// Jumps the scroll position from its current value to the given value,
  /// without animation, and without checking if the new value is in range.
  ///
  /// Any active animation is canceled. If the user is currently scrolling, that
  /// action is canceled.
  ///
  /// If this method changes the scroll position, a sequence of start/update/end
  /// scroll notifications will be dispatched. No overscroll notifications can
  /// be generated by this method.
  ///
  /// Immediately after the jump, a ballistic activity is started, in case the
  /// value was out of range.
  void jumpTo(double value) {
    for (final ScrollPosition position in List<ScrollPosition>.from(_positions))
      position.jumpTo(value);
  }

  /// 将ScrollPosition附着到该ScrollController
  ///
  /// 该函数返回后，该控制器上的[animateTo]和[jumpTo]方法将对给定位置进行操作。
  ///
  void attach(ScrollPosition position) {
    //添加到集合
    _positions.add(position);
    //position添加通知的回调
    position.addListener(notifyListeners);
  }

  /// Unregister the given position with this controller.
  ///
  /// After this function returns, the [animateTo] and [jumpTo] methods on this
  /// controller will not manipulate the given position.
  void detach(ScrollPosition position) {
    assert(_positions.contains(position));
    position.removeListener(notifyListeners);
    _positions.remove(position);
  }

  @override
  void dispose() {
    for (final ScrollPosition position in _positions)
      position.removeListener(notifyListeners);
    super.dispose();
  }

  /// 创建一个[ScrollPosition]供[Scrollable]widget使用。
  ///
  /// 子类可以重写这个函数来定制它们所控制的可滚动（scrollable）widget所使用的
  /// [ScrollPosition]。例如，[PageController]重写此函数，以返回一个面向页面的
  /// scroll position子类，当可滚动部件调整大小时，该子类保持仅一页面可见。
  ///
  /// 默认的，会返回一个[ScrollPositionWithSingleContext].
  ///
  /// 参数一般传递给正在创建的[ScrollPosition]：
  /// * `physics`。[ScrollPhysics]的一个实例，决定[ScrollPosition]应如何对用户交互作出
  ///   反应，如何模拟释放或甩动时的滚动等。该值不会为空。它通常来自于创建[Scrollable]的
  ///   [ScrollView]或其他部件，如果没有提供，则来自于环境[ScrollConfiguration]。
  /// * `context'。用于与拥有[ScrollPosition] 的对象(通常是[Scrollable] 本身)
  ///   通信的[ScrollContext]。
  /// * ‘oldPosition'：如果这不是第一次为该[Scrollable]创建[ScrollPosition]，则将是以
  ///   前的实例。当环境发生变化，[Scrollable]需要重新创建[ScrollPosition]对象时，就会使
  ///   用这个实例。第一次创建[ScrollPosition]时，该对象为空。
  ///
  ScrollPosition createScrollPosition(
      ScrollPhysics physics,
      ScrollContext context,
      ScrollPosition? oldPosition,
      ) {
    return ScrollPositionWithSingleContext(
      physics: physics,
      context: context,
      initialPixels: initialScrollOffset,
      keepScrollOffset: keepScrollOffset,
      oldPosition: oldPosition,
      debugLabel: debugLabel,
    );
  }


}
